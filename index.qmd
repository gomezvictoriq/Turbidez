---
title: "Algoritmo para la estimación de la turbidez sobre el Río Paraná"
format: 
  html:
    number-sections: true
    toc: true
    embed-resources: true
    crossrefs-hover: false
    lang: es
    bibliography: bibliografia/bibliografia.bib
    csl: bibliografia/ieee.csl
    theme: cosmo 
date: last-modified
author:
  - name: Víctor Gustavo Gómez
    corresponding: true
    email: gomezvictoriq@ca.frre.utn.edu.ar
    affiliations:
      - name: GISTAQ (UTN-FRRe)
        url: https://www.instagram.com/gistaq.utn/
abstract: |
  Este sitio web contiene información sobre la estimación de la turbidez por teledetección en la cuenca media del Río Paraná. 
  La turbidez es uno parámetros de interés dentro proyecto Estimar indicadores de calidad de agua en la cuenca media del río Paraná para el desarrollo de un algoritmo mediante técnicas de teledetección satelital (MSECRE0008604), desarrollado por el Grupo de Investigación Sobre Temas Ambientales y Químicos (GISTAQ) de la Universidad Tecnológica Nacional Facultad Regional Resistencia (UTN-FRRe).

  Se utilizarán imágenes del satélite Sentinel-2 con corrección automática, de las cuales se obtiene la reflectancia de superficie del agua. Se buscará la relación entre la reflectancia y la turbidez por métodos de regresión tradionales y machine learning. Una vez obtenido el algoritmo que relacione ambas propiedades, se desarrollaran mapas de distribución espacial.
  
keywords:
  - GISTAQ
  - UTN
  - FRRe
  - Algoritmo
  - Turbidez
  - Machine learning
  - Teledetección
---

# Turbidez

La turbidez se refiere a la opacidad o falta de claridad en un líquido provocada por la presencia de partículas suspendidas. Este fenómeno es un indicador clave en el monitoreo de la calidad del agua y su influencia en diferentes ecosistemas es significativa.

La turbidez es un indicador de la calidad del agua, reflejando la presencia de partículas en suspensión. Su medición es crucial para garantizar la potabilidad del agua y la salud de los ecosistemas acuáticos. Este fenómeno puede ser resultado de diversas causas, como la erosión del suelo, la actividad biológica y la contaminación. La comprensión de la turbidez y su impacto es esencial para la gestión de recursos hídricos y la protección del medio ambiente.

La turbidez viene determinada por la dispersión de la luz causada por la materia suspendida en el agua, se obtiene normalmente mediante un turbidímetro, que proporciona medidas en Nephelometric Turbidity Unit (NTU) y mide la dispersión de un rayo de luz en el agua a 90º de la luz incidente [@Delegido2019].

Muchas propiedades, como la clorofila-a (Chl-a), sólidos suspendidos totales (SST) y la materia orgánica disuelta coloreada (CDOM), se utilizan a menudo como indicadores del estado del agua. Estos constituyentes del agua a su vez son responsables de la turbidez.

Existe una fuerte correlación entre turbidez y sólidos suspendidos totales, por lo que se puede estimar SST a partir de la turbidez. Por lo general, es una relación directa, a mayor concentración de SST mayor turbidez.

Existe una relación inversa entre la Turbidez y la profundidad del disco de Secchi (a valores bajos de secchi mayor turbidez), por lo que también se puede estimar turbidez a partir de mediciones de disco de secchi.

## Métodos tradicionales

:::: {.content-visible when-format="html"}

::: {.column-screen-right}
<!-- TODO corregir <br> de la ecuación -->
| Ecuación | Bandas (nm) | Métricas | Aguas | Plataforma | Referencia |
|:-:|:--|:--|:--|:--|:-:|
| $1.559e^{35.533 \cdot B03} \\ 1.879e^{37.745(B03 \cdot B5)/(B04+B12)}$ | B03, B04, B05, B12 | $R^{2}$, RMSE, MAE | Lago^[0,83 - 112,26 NTU.] | Sentinel-2 | @Ma2021 |
| $2677.2 \cdot B04^{1.856}$ | B04 | $R^{2}$, RMSE, Bias | Interiores variadas^[2,3 - 107,02 NTU.] | Landsat-8 | @Hossain2021 |
| $969-1.5468 \cdot R_{1200nm}+2.07 \frac{B8A}{B02}$ | B02, B8A, 1200nm | IOA, SI, RMSE, MAE | Río^[IOA = index of agreement<br>SI = scatter index.] | Landsat-8 | @Najafzadeh2023 |
| $y=-1.1+5.8 \frac{B02}{B04} \\ y=3.896-4.186 \frac{B02}{B03}$ | B02, B03, B04 | $R^{2}$, RMSE | Río^[20,6 - 112 NTU<br>2,3 - 15,4 NTU.] | Landsat-8 | @Allam2020 |
| $y=37661 \cdot B8A^{2}+1845 \cdot B8A <br> y=531.5- \frac{B04}{0.88}$ | B04, B8A | $R^{2}$, RMSE, MAPE | Estuario^[MAPE = Mean Absolute Percentage Error<br>0 - 1300 NTU<br>0 - 80 NTU.] | Pléiades | @Luo2020 |

: Características principales de algoritmos tradicionales para la estimación de turbidez. {#tbl-turb-trad .striped .hover tbl-colwidths="[40,15,15,10,10]"}

:::

::::


Múltiples modelos (lineal, logaritmos, inversa, cuadrática, exponencial, potencial) y plataformas (Sentinel-2, Landsat-5 y Landsat-8) emplean el cociente de bandas B04/B03 [@Shen2021].

Modelos de estimación a partir de Sentinel-2 y Landsat-8 utilizan regresiones lineales, cuadráticas y logarítmicas empleando B02, B03, B04, B01 (con menos apariciones) y cocientes entre éstas [@Ouma2020].

## Métodos de aprendizaje automático

El aprendizaje automático es un subconjunto de la inteligencia artificial que permite que un sistema aprenda y mejore de forma autónoma, sin necesidad de una programación explícita, a través del análisis de grandes cantidades de datos. El aprendizaje automático permite que los sistemas informáticos se ajusten y mejoren continuamente a medida que acumulan más "experiencias". Por lo tanto, el rendimiento de estos sistemas puede mejorar si se proporcionan conjuntos de datos más grandes y variados para su procesamiento.

Cuando se entrenan modelos de machine learning, cada conjunto de datos y cada modelo necesitan un conjunto diferente de "hiperparámetros".
Los hiperparámetros son variables de configuración externa que se utilizan para administrar el entrenamiento de modelos de machine learning. Controlan de forma directa la estructura, funciones y rendimiento de los modelos.
Los hiperparámetros son los parámetros de un modelo de aprendizaje automático, que no se aprenden durante el entrenamiento, sino que se establecen antes de que comience.

El "ajuste de hiperparámetros" permite modificar el rendimiento del modelo para lograr resultados óptimos. Este proceso es una parte fundamental del machine learning.
El ajuste de hiperparámetros puede ser manual o automático. A pesar de que el ajuste manual es lento y tedioso, permite entender mejor cómo afectan al modelo las ponderaciones de los hiperparámetros. El proceso de ajuste de hiperparámetros es iterativo, y debe probar diferentes combinaciones de parámetros y valores.

En el aprendizaje automático es importante utilizar técnicas de "validación cruzada" , de modo que el modelo no se centre únicamente en una única porción de sus datos.
La validación cruzada o cross-validation es una técnica utilizada para evaluar los resultados de un análisis estadístico y garantizar que son independientes de la partición entre datos de entrenamiento y prueba.
La idea básica de la validación cruzada es dividir los datos en conjuntos de entrenamiento y validación, y luego entrenar el modelo en el conjunto de entrenamiento y evaluar su rendimiento en el conjunto de validación. Este proceso se repite varias veces, con diferentes subconjuntos de los datos utilizados para el entrenamiento y la validación, y se calcula el rendimiento promedio.

En los procesos de machine learning supervisado se utilizan diversos algoritmos y técnicas de cálculo, generalmente calculados mediante el uso de programas como R o Python.

Dependiendo del tipo de datos que se usen para el entrenamiento, será de modelo de aprendizaje automático que se use.
A grandes rasgos, existen tres tipos de modelos que se usan en el aprendizaje automático: aprendizaje supervisado , no supervisado y por refuerzo.

Consultando el trabajo de otros investigadores, se observa que utilizan principalmente el aprendizaje automático supervisado.
Este tipo aprendizaje supervisado utiliza un conjunto de entrenamiento para enseñar a los modelos a producir el resultado deseado. Este conjunto de datos de entrenamiento incluye entradas y salidas correctas, que permiten al modelo aprender con el tiempo. El algoritmo mide su precisión a través de la función de pérdida, ajustando hasta que el error se haya minimizado lo suficiente.

Yang Zhe y otros, utilizaron como datos de entrada la reflectancia de superficie y datos de salida la turbidez, utilizaron los modelos SVR (support vector regression), random forest (RF) y eXtreme Gradiente Boostring (XGBoost).
Los hiperparámetros de cada modelo se determinaron mediante una búsqueda en cuadrícula de validación cruzada en Scikit-Learn de Python [@Yang2023].

Ma Yue y otros, utilizaron varios modelos de aprendizaje automático, usaron Python 3.7 tanto para la predicción de la turbidez del agua y la optimización de la los hiperparámetros [@Ma2021].

Zhao y otros probaron 14 modelos de machine learning en un estanque de peces con un dispositivo de construction propia, de los cuales ETR, Bagging, RFR, and ABR son los que presentaron un mejor desempeño en la estimación de la turbidez. Los algoritmos se implementaron utilizando Python 3.6 y bibliotecas de aprendizaje
scikit [@Zhao2022].

:::: {.content-visible when-format="html"}

::: {.column-screen-right}

|Modelo de machine learning|Cuerpo de agua|Métricas|Plataforma| Referencia |
|:--|:--|:--|:--|:-:|
|SVR, ELM ,BP ,CART ,GBT ,RF ,KNN|Lagos|RMSE, $R^{2}$, MAE|Sentinel-MSI|@Ma2021|
|eXtreme Gradient Boosting (XGBoost),  support vector regression (SVR), random forest (RF)|Lago|RMSE, $R^{2}$, MAPE| Sentinel-2A/B y Landsat-8/9 |  @Yang2023 |
| linear regression (LR), ridge regression (RR),  least absolute shrinkage and selection operator regression(LASSO), elastic net regression (ENR),  k-nearest neighbor regression (KNN), Gaussian process regression (GPR), decision tree regression (DTR), support vector regression (SVR), multilayer perceptron regression (MLP), adaptive boosting regression (ABR), gradient boosting regression (GBR), bootstrap aggregating regression (Bagging), random forest regression (RFR), and extreme tree regression (ETR) | Estanque de peces | MAE, MRSE, MAPE, $R^{2}$, RE, Acc |Propia| @Zhao2022 |

: Características principales de algoritmos de aprendizaje automático para la estimación de turbidez. {#tbl-turb-machine .striped .hover tbl-colwidths="[50,13,13,14,10]"}

:::

::::

# Procesamiento de datos

Para el procesamiento de los datos se utilizará la librería *pandas* de Python.

En el proyecto tenemos dos archivos .csv que contienen los datos:

-base_de_datos_lab.csv → contiene resultados de laboratorio 

-base_de_datos_gis.csv → contiene datos espectrales

**Importamos la librería *pandas* para usarla, la nombramos como "pd" para simplificar**

```{python}
import pandas as pd
```

**Leemos los archivos .csv por separado y definimos dos DataFrame**

Un DataFrame es basicamente una tabla, donde la información se organiza en filas y columnas. Los datos de la misma columna contienen el mismo tipo de datos, pandas agrega por defecto un "índice" que nos ayuda a identificar una fila en particular.

Con la función *pd.read_csv* le idicamos a pandas que queremos leer archivos .csv.

```{python}
df1_lab = pd.read_csv(r"D:\GIT\Turbidez\datos\base_de_datos_lab.csv")
df2_gis = pd.read_csv(r"D:\GIT\Turbidez\datos\base_de_datos_gis.csv")
```

**df1_lab** DataFrame de datos provenientes del laboratorio.

**df2_gis** DataFrame de datos espectrales provenientes del sensor MSI de Sentinel-2.

**Nota:** Se debió colocar la "r" delante de la dirección para que lea los archivos.

Video de YouTube [¿Qué es un DataFrame?](https://www.youtube.com/watch?v=LnH_STJ2GXo)  

Verificamos que los datos se han leído y se crearon correctamente ambos DataFrame por separado, con *print* 

```{python}
print(df1_lab.head())
print(df2_gis)
```

**Nota:** La primer columna (donde se ven los valores 0,1,2,3,4, ...) es el *índice* que agrega pandas por defecto al DataFrame, esa columna no forma parte del csv original.

**Hacemos un filtrado en el DataFrame de datos espectrales**

En la tabla original de los datos espectrales en la columna *pixel* se menciona 1x1 y 3x3. Cada píxel contiene un valor de reflectancia medida por el sensor de Sentinel-2.

El valor de reflectancia de un único píxel (1x1) puede estar afectado por el de los píxeles adyacentes. Para considerar este efecto, se reliazó una grila de 3x3 aldedor del pixel central. Luego se calcula el promedio de la reflectancia de todos los píxeles (incluído el central). Tomamos este valor promedio para nuestro estudio, por lo que se conservan unicamente las filas donde pixel=3x3, 

**IMPORTANTE**: Esta etapa es necesaria realizarla, porque hay valores de reflectancia tanto para píxles de 1x1 y de 3x3, y a la hora de operar con la tabla la librería *pandas* tomará ambos valores y realizará cálculos erroneos.

Para esto, realizamos un filtrado y creamos un nuevo DataFrame **"df_gis3x3"**, el cual se obtiene al hacer un filtrado en el DataFrame original. 

```{python}
df_gis3x3 = df2_gis[(df2_gis['pixel'] == '3x3')]
print(df_gis3x3.head())
```

**Nota:** se conserva el índice del original

**Combinamos ambos DataFrame para tener los datos en una única base de datos.**

Lo defimos como **df_combinado**, para esto utilizamos la función *pd.merge* para realizar la combinación.

```{python}
df_combinado = pd.merge(df1_lab, df_gis3x3, on=['latitud', 'longitud','fecha'], how='inner')
```

**on=['latitud', 'longitud','fecha']**	Especifica las columnas por las cuales se unirán los dos DataFrames. En este caso, por coincidencias exactas en latitud, longitud y fecha.

**how='inner'**	Es el tipo de unión, significa que solo se conservarán las filas que tengan coincidencias en ambos DataFrames en las columnas mencionadas.

Verificamos que la combinacion se haya realizado correctamente

```{python}
print(df_combinado.head())
```

**Filtramos la turbidez del DataFrame**

Del DataFrame combinado, solo nos interesa las filas que contengan los valores de turbidez, ya que es la propiedad de estudio en este sitio web. Por ello nos quedamos con las filas en donde la columna *param* sea igual a *turb*.

Creamos un nuevo DataFrame a partir de *df_combinado*.
```{python}
df_turbidez = df_combinado[(df_combinado['param'] == 'turb')]
```

Verificamos
```{python}
print(df_turbidez.head())
```

**Nota:** Se han eliminado las filas de ph, cond, sol_sus, etc. Se conserva el índice del DataFrame original.

**Eliminamos las columnas que no nos interesan**

Creamos un nuevo DataFrame a partir de *df_turbidez*. Con la función **.drop** especificamos que columnas queremos eliminar.

```{python}
df_turbidez_banda = df_turbidez.drop(columns=['longitud','latitud','punto','pixel','fecha','param'])

print(df_turbidez_banda.head())
```

**Nota:** Solo nos quedamos con las columnas valor,banda y reflect.

**Cambiamos el nombre de la columna "valor" por el de "turbidez"**
Como los valores de esa columna son de turbidez, directamente cambiamos el nombre de la columna con la función **.rename**

```{python}
df_turbidez_banda.rename(columns={'valor': 'turbidez'}, inplace=True)

print(df_turbidez_banda.head())
```

**Creamos la tabla final**

Usamos la función **.pivot_table** para que las columnas sean la turbidez y las distintas bandas de Sentinel-2 (B01, B02 , B03...)

```{python}
df_final = df_turbidez_banda.pivot_table(
    index='turbidez',
    columns='banda',
    values='reflect',  
    )
```

¿Qué significa cada término en el argumento de la función pivot_table?

index='turbidez' → Las filas serán los valores únicos de 'turbidez'

columns='banda'  → Las columnas serán los valores únicos de 'banda' (B01, B02...)

values='reflect' → El contenido de la tabla será lo que haya en la columna 'reflect'

**Creamos archivo final con los valores de turbidez y reflectancia de cada banda**

***-Forma 1***
Creamos un .csv con los datos que nos interesan con la función **.to_csv**

```{python}
 df_final.to_csv('Turbidez_FINAL.csv', index=True)
```

**IMPORTANTE:** **index=True** , debe ser así para que el índice que definimos al pivotar sea una columna visible en el archivo csv.

Recordemos que la columna **index** es solo visible solo por la librería *pandas*, 
Si guardamos con **index=False**, se omite y no se guarda en el csv.

***-Forma 2***
Si decidimos poner **index=False** tenemos que usar una función adicional antes de exportar, debido a que la turbidez está en el índice, no como una columna.

Por lo tanto, luego de hacer el pivot se debe agregar una línea de código.

```{python}
df_final = df_turbidez_banda.pivot_table(
    index='turbidez',
    columns='banda',
    values='reflect',  
    )

df_final = df_final.reset_index() #Línea de código que se debe agregar
```

**reset_index()** convierte el índice definido previamente como "turbidez" en una columna normal y reemplaza el índice por uno numérico estándar (0, 1, 2...). que es el predeterminado por pandas.

Finalmente exportamos como archivo csv.
```{python}
df_final.to_csv('Turbidez_FINAL2.csv', index=False)
```

**Verificación tabla final**

```{python}
import pandas as pd

df = pd.read_csv(r'D:\GIT\Turbidez\Turbidez_FINAL.csv')
print(df.head())
```

# Prueba de modelo lineal

**Regresión lineal con método de mínimos cuadrados**

Reemplamos el código del tutorial de sklearn por nuestros datos.

Debemos importar las funciones necesarias para:

1- Leer el archivo .csv creado previamente , que contiene los datos de turbidez y los valores de reflectancia para cada banda.

2- Para usar el método de mínimos cuadrados

**Importamos las funciones**
```{python}
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
import matplotlib.pyplot as plt
```

*pandas* → para leer los datos

*train_test_split* → para dividir los datos en entrenamiento y validación

*LinearRegression* → para crear el modelo de regresión lineal

*mean_squared_error* y *r2_score* → Para medir el desempeño del modelo (RMSE y R2)

*matplotlib.pyplot* → para realizar gráficos

**Leemos los datos de interés y los dividimos en entrenamiento y validación.**

Lectura de datos, lo hacemos con *pd.read_csv*

```{python}
df = pd.read_csv(r"D:\GIT\Turbidez\Turbidez_FINAL.csv")

X = df[['B05']]  
y = df['turbidez']  
```

Definimos: 

**df**, un DataFrame que contiene los datos de turbidez y reflectancia;

**X** para que sea los valores de reflectancia de una banda en particular;

**y** para que sea la turbidez.

**Dividimos en datos para el entrenamiento y validación**
```{python}
X_train, X_test, y_train, y_test = train_test_split(
  X, y, test_size=0.25, shuffle=True, random_state=42 
)
```

Conjunto de datos para el entrenamiento
**X_train** y **X_test**

Conjunto de datos para la validación
**y_train** y **y_test**

**Creamos el modelo de regresión**

```{python}
regressor = LinearRegression().fit(X_train, y_train)
```

**LinearRegression()** Crea el modelo de regresión lineal llamado "*regressor*". Este modelo, se entrena con la función **.fit** a partir de los datos de entrenamiento (X_train, y_train)


**Evaluamos el modelo generado a partir de las métricas de desempeño.**

```{python}
y_pred = regressor.predict(X_test)
p_rmse = mean_squared_error(y_test, y_pred)
p_r2 = r2_score(y_test, y_pred)
```
Con la función **print** visualizamos los valores de las métricas de desempeño
```{python}
print("RMSE", p_rmse) 
print("R2", p_r2)
```

Para ver la ecuación del modelo de regresión

```{python}
# Coeficientes (pendientes)
coef = regressor.coef_

# Intercepto (ordenada al origen)
intercept = regressor.intercept_

print(f"La ecuación es: y = {coef[0]:.3f}x + {intercept:.3f}")
```

**Visualizamos los resultados comparando el conjunto de entrenamiento y validación.**
```{python}
#| code-fold: true
fig, ax = plt.subplots(ncols=2, figsize=(10, 5), sharex=True, sharey=True)

#Gráfico de entrenamiento
ax[0].plot(
    X_train,
    regressor.predict(X_train),
    linewidth=3,
    color="#17A77E",
    label="Modelo",
)

ax[0].scatter(X_train, y_train, label="Entrenamiento", color = "#9D50A6", alpha = .6)
ax[0].set(xlabel="Banda 5", ylabel="Turbidez", title="Conjunto de entrenamiento")
ax[0].legend()

#Gráfico de validación
ax[1].plot(X_test, y_pred, linewidth=3, color="#17A77E", label="Modelo")
ax[1].scatter(X_test, y_test, label="Validación", color = "#9D50A6", alpha = .6)
ax[1].set(xlabel="Banda 5", ylabel="Turbidez", title="Conjunto de validación")
ax[1].legend()

#Ecuación de la recta
coef = regressor.coef_[0]
intercept = regressor.intercept_
equation = f"y = {coef:.2f}x + {intercept:.2f}"
# Mostrar la ecuación en ambos subgráficos (opcionalmente, puedes usar solo uno)
for a in ax:
    a.text(0.05, 0.95, equation, transform=a.transAxes,
           fontsize=10, verticalalignment='top',
           bbox=dict(boxstyle="round", facecolor="white", alpha=0.7))

fig.suptitle("Regresión lineal")

plt.show()
```


# Pruebas de correlación
## Prueba de correlación C1: turbidez vs bandas
Para ser mas rigurosos, agregamos mas etapas durante el entrenamiento de nuestro modelo lineal.

**Importamos *pandas* para leer los datos**

```{python}
#| code-fold: true
import pandas as pd

Datos= pd.read_csv(r'D:\GIT\Turbidez\Turbidez_FINAL.csv')
#print (Datos.head())
```

**Calculamos coeficiente de correlacion lineal "r" entre la turbidez y cada banda con la función *.corr* de pandas.** 

Esta medida indica cuanto se relacionan dos variables, puede tomar valores desde -1 a +1: 

• +1 correlación lineal perfecta positiva.

•  0 sin correlación.

• -1 correlación lineal perfecta negativa.

```{python}
#| code-fold: true
bandas = [col for col in Datos.columns if col.startswith('B')]

correlaciones = {}

for banda in bandas:
    r = Datos['turbidez'].corr(Datos[banda])
    correlaciones[banda] = r

#Creamos un Data Frame.
df_correlaciones1 = pd.DataFrame(list(correlaciones.items()), columns=['Banda', 'r'])
#Ordenamos por mayor a menos valor de r.
df_correlaciones1 = df_correlaciones1.sort_values(by='r', ascending=False).reset_index(drop=True)

df_correlaciones1['Banda'] = "turb vs " + df_correlaciones1['Banda'].astype(str)
df_correlaciones1.rename(columns={'Banda': 'Correlación 1'}, inplace=True)

df_correlaciones1.to_csv(r'D:\GIT\Turbidez\Datos creados\Correlaciones\C1_turb_vs_banda.csv', index=False)

df_correlaciones1
```

Observamos que el mejor valor se obtiene con **turb vs B05 = 0.8719**

**Gráfica**
```{python}
#| code-fold: true
import matplotlib.pyplot as plt

plt.figure(figsize=(5, 5))
plt.scatter(Datos['B05'], Datos['turbidez'], color='blue', alpha=0.7)
plt.xlabel('B05')
plt.ylabel('Turbidez')
plt.title('Turbidez vs B05')
plt.grid(True)

descripcion = "Figura 1: Este gráfico de dispersión muestra la relación entre la banda espectral B05 y la turbidez del agua."
plt.figtext(0.5, -0.04, descripcion,
            wrap=True,                  # Permite que el texto se ajuste en varias líneas
            horizontalalignment='center', # Centra el texto horizontalmente
            fontsize=9,                 # Tamaño de la fuente
            color='gray'                # Color del texto (comúnmente gris para pies de figura)
           )

plt.show()
```

## Prueba de correlación C2: ln(turbidez) vs bandas

**Importamos *nunpy* para operar con funciones matemáticas**

Creamos un nuevo DataFrame para aplicarle el logaritmo a la colomna turbidez 

```{python}
#| code-fold: true
import numpy as np

Datos_turb_log = pd.read_csv(r'D:\GIT\Turbidez\Turbidez_FINAL.csv')
Datos_turb_log['turbidez'] = np.log(Datos_turb_log['turbidez'])

#Cambio el nombre la columna "turbidez" luego de aplicar el logaritmo
Datos_turb_log = Datos_turb_log.rename(columns={'turbidez': 'ln_turbidez'})

#print(Datos_turb_log.head())

```

Calculamos *r* entre el ln_turb y cada banda, con la función **.corr** de pandas. 

```{python}
#| code-fold: true
bandas = [col for col in Datos_turb_log.columns if col.startswith('B')]

correlaciones = {}

for banda in bandas:
    r = Datos_turb_log['ln_turbidez'].corr(Datos_turb_log[banda])
    correlaciones[banda] = r

#Creamos un Data Frame.
df_correlaciones2 = pd.DataFrame(list(correlaciones.items()), columns=['Banda', 'r'])
#Ordenamos por mayor a menos valor de r.
df_correlaciones2 = df_correlaciones2.sort_values(by='r', ascending=False).reset_index(drop=True)

df_correlaciones2['Banda'] = "ln_turb vs " + df_correlaciones2['Banda'].astype(str)
df_correlaciones2.rename(columns={'Banda': 'Correlación 2'}, inplace=True)

df_correlaciones2.to_csv(r'D:\GIT\Turbidez\Datos creados\Correlaciones\C2_ln_turb_vs_banda.csv', index=False)

df_correlaciones2
```
Observamos que el mejor valor se obtiene con **ln_turb vs B05 = 0.7267**

**Gráfica**
```{python}
#| code-fold: true
import matplotlib.pyplot as plt

plt.figure(figsize=(5, 5))
plt.scatter(Datos_turb_log['B05'], Datos_turb_log['ln_turbidez'], color='blue', alpha=0.7)
plt.xlabel('B05')
plt.ylabel('ln(turbidez)')
plt.title('ln(turbidez) vs B05')
plt.grid(True)

descripcion = "Figura 2: Este gráfico de dispersión muestra la relación entre la banda espectral B05 y logaritmo de la turbidez del agua. Se observa poca linealidad entre ambas."
plt.figtext(0.5, -0.06, descripcion,
            wrap=True,                  # Permite que el texto se ajuste en varias líneas
            horizontalalignment='center', # Centra el texto horizontalmente
            fontsize=9,                 # Tamaño de la fuente
            color='gray'                # Color del texto (comúnmente gris para pies de figura)
           )

plt.show()
```

## Prueba de correlación C3: turbidez vs ln(bandas)

**Importamos *nunpy* para operar con funciones matemáticas**

Creaamos un nuevo DataFrame para aplicarle el logaritmo a todas las columnas 

```{python}
#| code-fold: true
import numpy as np
import pandas as pd

Banda_log = pd.read_csv(r'D:\GIT\Turbidez\Turbidez_FINAL.csv')

col = [col for col in Banda_log.columns if col.startswith('B')]

Banda_log[col] = np.log(Banda_log[col])

#Cambiamos en nombre las columnas, agremamos ln_ a cada columna

Banda_log.columns = ['ln_' + col for col in Banda_log.columns]

Banda_log.rename(columns={'ln_turbidez': 'turbidez'}, inplace=True)

Banda_log.to_csv(r"D:\GIT\Turbidez\Datos creados\Datos_turb_banda\turb_vs_ln_banda.csv", index=False)

#print(Banda_log.head())
```

Calculamos *r* entre el ln_turb y ln de cada banda, con la función **.corr** de pandas. 

```{python}
#| code-fold: true
bandas_ln = [col for col in Banda_log.columns if col.startswith('ln_B')]

correlaciones = {}

for banda in bandas_ln:
    r = Banda_log['turbidez'].corr(Banda_log[banda])
    correlaciones[banda] = r

#Creamos un Data Frame.
df_correlaciones3 = pd.DataFrame(list(correlaciones.items()), columns=['Banda', 'r'])
#Ordenamos por mayor a menos valor de r.
df_correlaciones3 = df_correlaciones3.sort_values(by='r', ascending=False).reset_index(drop=True)

df_correlaciones3['Banda'] = "turb vs " + df_correlaciones3['Banda'].astype(str)
df_correlaciones3.rename(columns={'Banda': 'Correlación 3'}, inplace=True)


df_correlaciones3.to_csv(r'D:\GIT\Turbidez\Datos creados\Correlaciones\C3_turb_vs_ln_banda.csv', index=False)

df_correlaciones3
```
Observamos que el mejor valor se obtiene con **turb vs ln_B05  0.8320**

**Gráfica**
```{python}
#| code-fold: true
import matplotlib.pyplot as plt

plt.figure(figsize=(5, 5))
plt.scatter(Banda_log['ln_B05'], Banda_log['turbidez'], color='blue', alpha=0.7)
plt.xlabel('ln(B05)')
plt.ylabel('turbidez')
plt.title('turbidez vs de ln(B05)')
plt.grid(True)

descripcion = "Figura 3: Este gráfico de dispersión muestra la relación entre ln(B05) y turbidez. Se observa una mejora de la linealidad entre ambas."
plt.figtext(0.5, -0.04, descripcion,
            wrap=True,                  # Permite que el texto se ajuste en varias líneas
            horizontalalignment='center', # Centra el texto horizontalmente
            fontsize=9,                 # Tamaño de la fuente
            color='gray'                # Color del texto (comúnmente gris para pies de figura)
           )

plt.show()
```

## Prueba de correlación C4: ln(turbidez) vs ln(bandas)

**Importamos *nunpy* para operar con funciones matemáticas**

Creaamos un nuevo DataFrame para aplicarle el logaritmo a todas las columnas 

```{python}
#| code-fold: true
import numpy as np

Datos_log = pd.read_csv(r'D:\GIT\Turbidez\Turbidez_FINAL.csv')
Datos_log = np.log(Datos_log)
#Cambiamos en nombre las columnas, agremamos ln_ a cada columna
Datos_log.columns = ['ln_' + col for col in Datos_log.columns]
#print(Datos_log.head())
```

Calculamos *r* entre el ln_turb y ln de cada banda, con la función **.corr** de pandas. 

```{python}
#| code-fold: true
bandas_ln = [col for col in Datos_log.columns if col.startswith('ln_B')]

correlaciones = {}

for banda in bandas_ln:
    r = Datos_log['ln_turbidez'].corr(Datos_log[banda])
    correlaciones[banda] = r

#Creamos un Data Frame.
df_correlaciones4 = pd.DataFrame(list(correlaciones.items()), columns=['Banda', 'r'])
#Ordenamos por mayor a menos valor de r.
df_correlaciones4 = df_correlaciones4.sort_values(by='r', ascending=False).reset_index(drop=True)

df_correlaciones4['Banda'] = "ln_turb vs " + df_correlaciones4['Banda'].astype(str)
df_correlaciones4.rename(columns={'Banda': 'Correlación 4'}, inplace=True)

df_correlaciones4.to_csv(r'D:\GIT\Turbidez\Datos creados\Correlaciones\C4_ln_turb_vs_ln_banda.csv', index=False)

df_correlaciones4
```
Observamos que el mejor valor se obtiene con **ln_turb vs ln_B05  0.7716**

**Gráfica**
```{python}
#| code-fold: true
import matplotlib.pyplot as plt

plt.figure(figsize=(5, 5))
plt.scatter(Datos_log['ln_B05'], Datos_log['ln_turbidez'], color='blue', alpha=0.7)
plt.xlabel('ln(B05)')
plt.ylabel('ln(turbidez)')
plt.title('ln(turbidez) vs de ln(B05)')
plt.grid(True)

descripcion = "Figura 3: Este gráfico de dispersión muestra la relación entre ln(B05) y ln(turbidez)."
plt.figtext(0.5, -0.04, descripcion,
            wrap=True,                  # Permite que el texto se ajuste en varias líneas
            horizontalalignment='center', # Centra el texto horizontalmente
            fontsize=9,                 # Tamaño de la fuente
            color='gray'                # Color del texto (comúnmente gris para pies de figura)
           )

plt.show()
```

# Seleción de variables
Se resume en una tabla las pruebas de correlación realizadas.
```{python}
#| code-fold: true
import pandas as pd 

C1 = pd.read_csv(r"D:\GIT\Turbidez\Datos creados\Correlaciones\C1_turb_vs_banda.csv")
C2= pd.read_csv(r"D:\GIT\Turbidez\Datos creados\Correlaciones\C2_ln_turb_vs_banda.csv")
C3 = pd.read_csv(r"D:\GIT\Turbidez\Datos creados\Correlaciones\C3_turb_vs_ln_banda.csv")
C4 = pd.read_csv(r"D:\GIT\Turbidez\Datos creados\Correlaciones\C4_ln_turb_vs_ln_banda.csv")

C_comb = pd.concat([C1, C2 ,C3, C4], axis=1)

C_comb
```

Se puede observar que en C1 y C3 las correlaciones son mas altas respecto a C2 y C4. Por que que se seguirá el análisis con estas combinaciones:

  • turb (bandas)

  • turb (ln_bandas)

Se probarán modelos con ambas combinaciones por separado y se evalurá su desempeño.

Se utilizará *AIC* @Chatterjee2015, como criterio para la selección de variables.

## Combinación 1: turb(bandas)
```{python}
#| code-fold: true
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
import matplotlib.pyplot as plt
import numpy as np

Datos = pd.read_csv(r"D:\GIT\Turbidez\Datos creados\Datos_turb_banda\turb_vs_banda.csv")

# Variable objetivo
y = Datos['turbidez']

# Variable fija (B05 siempre presente)
variables_fijas = ['B05']

# Variables que se irán agregando en orden específico (según tabla de correlaciones 1)
variables_a_agregar = ['B08', 'B07', 'B06', 'B04', 'B8A', 'B03', 'B02', 'B01', 'B12' , 'B11']  # Se puede agregar o cambiar el orden

# Lista para guardar resultados
resultados = []

# Proceso de entrenamiento incremental
for i in range(len(variables_a_agregar) + 1):
    # Usamos solo las variables fijas al principio
    variables_usadas = variables_fijas + variables_a_agregar[:i]

    # Seleccionamos los datos correspondientes
    X = Datos[variables_usadas]
    
    # División entrenamiento/prueba
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, shuffle=True, random_state=42)
    
    # Entrenar modelo
    modelo = LinearRegression()
    modelo.fit(X_train, y_train)
    
    # Predicción y evaluación
    y_pred = modelo.predict(X_test)
    r2 = r2_score(y_test, y_pred)
    rmse = np.sqrt(mean_squared_error(y_test, y_pred))

    # Cálculo R2-ajustado

    i = len(y)
    j = X.shape[1]
    r2_ajustado = 1 - (1 - r2) * (i - 1) / (i - j - 1)

    # Cálculo de AIC
    n = len(y_test)
    residuals = y_test - y_pred
    rss = np.sum(residuals ** 2)
    k = X_test.shape[1] + 1  # +1 por el intercepto
    aic = n * np.log(rss / n) + 2 * k


    # Guardamos los resultados
    resultados.append({
        "variables": ", ".join(variables_usadas),
        "num_variables": len(variables_usadas),
        "R²": r2,
        "R²-ajustado": r2_ajustado,
        "RMSE": rmse,
        "AIC": aic
    })
    
df_resultados = pd.DataFrame(resultados)
df_resultados

```

**Gráfico de AIC**

```{python}
#| code-fold: true
aic_scores = [r["AIC"] for r in resultados]
n_vars = [r["num_variables"] for r in resultados]

plt.plot(n_vars, aic_scores, marker='o', color='purple')
plt.title('AIC vs Número de Variables')
plt.xlabel('Número de variables')
plt.ylabel('AIC')
plt.grid(True)
plt.show()
```
## Combinación 2: turb(ln_bandas).
```{python}
#| code-fold: true
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd


Datos = pd.read_csv(r"D:\GIT\Turbidez\Datos creados\Datos_turb_banda\turb_vs_ln_banda.csv")

#Variable objetivo
y = Datos['turbidez']

#Variable fija (B05 siempre presente)
variables_fijas = ['ln_B05']

#Variables que se irán agregando en orden específico (según tabla de correlaciones 3)
variables_a_agregar = ['ln_B08', 'ln_B07', 'ln_B06', 'ln_B04', 'ln_B8A', 'ln_B03', 'ln_B02', 'ln_B01', 'ln_B12' , 'ln_B11']

#Lista para guardar resultados
resultados = []

#Proceso de entrenamiento incremental
for i in range(len(variables_a_agregar) + 1):
    # Usamos solo las variables fijas al principio
    variables_usadas = variables_fijas + variables_a_agregar[:i]

    # Seleccionamos los datos correspondientes
    X = Datos[variables_usadas]
    
    # División entrenamiento/prueba
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, shuffle=True, random_state=42)
    
    # Entrenar modelo
    modelo = LinearRegression()
    modelo.fit(X_train, y_train)
    
    # Predicción y evaluación
    y_pred = modelo.predict(X_test)
    r2 = r2_score(y_test, y_pred)
    rmse = np.sqrt(mean_squared_error(y_test, y_pred))

    # Cálculo R2-ajustado

    i = len(y)
    j = X.shape[1]
    r2_ajustado = 1 - (1 - r2) * (i - 1) / (i - j - 1)

    # Cálculo de AIC
    n = len(y_test)
    residuals = y_test - y_pred
    rss = np.sum(residuals ** 2)
    k = X_test.shape[1] + 1  # +1 por el intercepto
    aic = n * np.log(rss / n) + 2 * k


    # Guardamos los resultados
    resultados.append({
        "variables": ", ".join(variables_usadas),
        "num_variables": len(variables_usadas),
        "R²": r2,
        "R²-ajustado": r2_ajustado,
        "RMSE": rmse,
        "AIC": aic
    })
    
df_resultados = pd.DataFrame(resultados)
df_resultados
```
**Gráfico de AIC**
```{python}
#| code-fold: true
aic_scores = [r["AIC"] for r in resultados]
n_vars = [r["num_variables"] for r in resultados]

plt.plot(n_vars, aic_scores, marker='o', color='purple')
plt.title('AIC vs Número de Variables')
plt.xlabel('Número de variables')
plt.ylabel('AIC')
plt.grid(True)
plt.show()
```

# Modelos combinacion 1: turb(bandas)
## Modelo con B05

```{python}
#| code-fold: true
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
import matplotlib.pyplot as plt


Datos = pd.read_csv(r"D:\GIT\Turbidez\Datos creados\Datos_turb_banda\turb_vs_banda.csv")
X = Datos[['B05']]  
y = Datos['turbidez']  

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.25, shuffle=True, random_state=42
)

#test_size=0.25 significa que usamos el 25% de los datos para el testeo y el %75 restante para el entrenamiento 

modelo = LinearRegression()
modelo.fit(X_train, y_train)

# Predicciones
y_pred = modelo.predict(X_test)

# Métricas
r2 = r2_score(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))

print(f"R²: {r2:.4f}")
print(f"RMSE: {rmse:.4f}")

#Ver coefidiones del modelo
print("Intercepto:", modelo.intercept_)
print("Coeficientes:")
for nombre, coef in zip(X.columns, modelo.coef_):
    print(f"{nombre}: {coef:.4f}")

# Predicciones para entrenamiento y test
y_train_pred = modelo.predict(X_train)
y_test_pred = modelo.predict(X_test)

plt.figure(figsize=(10, 6))

# Entrenamiento
plt.scatter(y_train, y_train_pred, color='blue', label='Entrenamiento', alpha=0.6)

# Test
plt.scatter(y_test, y_test_pred, color='green', label='Test', alpha=0.6)

# Línea ideal (y = x)
min_val = min(min(y_train), min(y_test))
max_val = max(max(y_train), max(y_test))
plt.plot([min_val, max_val], [min_val, max_val], 'k--', lw=2, label='Ideal')

plt.xlabel('Turbidez real')
plt.ylabel('Turbidez predicha')
plt.title('Regresión Lineal: Valores Reales vs. Predichos')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()
```

## Modelo con 6 bandas

```{python}
#| code-fold: true
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
import matplotlib.pyplot as plt


Datos = pd.read_csv(r"D:\GIT\Turbidez\Datos creados\Datos_turb_banda\turb_vs_banda.csv")
X = Datos[['B05', 'B08', 'B07', 'B06', 'B04', 'B8A']]  
y = Datos['turbidez']  

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.25, shuffle=True, random_state=42
)

modelo = LinearRegression()
modelo.fit(X_train, y_train)

# Predicciones
y_pred = modelo.predict(X_test)

# Métricas
r2 = r2_score(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))

print(f"R²: {r2:.4f}")
print(f"RMSE: {rmse:.4f}")

#Ver coefidiones del modelo
print("Intercepto:", modelo.intercept_)
print("Coeficientes:")
for nombre, coef in zip(X.columns, modelo.coef_):
    print(f"{nombre}: {coef:.4f}")

# Predicciones para entrenamiento y test
y_train_pred = modelo.predict(X_train)
y_test_pred = modelo.predict(X_test)

plt.figure(figsize=(10, 6))

# Entrenamiento
plt.scatter(y_train, y_train_pred, color='blue', label='Entrenamiento', alpha=0.6)

# Test
plt.scatter(y_test, y_test_pred, color='green', label='Test', alpha=0.6)

# Línea ideal (y = x)
min_val = min(min(y_train), min(y_test))
max_val = max(max(y_train), max(y_test))
plt.plot([min_val, max_val], [min_val, max_val], 'k--', lw=2, label='Ideal')

plt.xlabel('Turbidez real')
plt.ylabel('Turbidez predicha')
plt.title('Regresión Lineal: Valores Reales vs. Predichos')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

```

# Modelos combinacion 2: turb(ln_bandas)
## Modelo con ln(B05)

```{python}
#| code-fold: true
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
import matplotlib.pyplot as plt


Datos = pd.read_csv(r"D:\GIT\Turbidez\Datos creados\Datos_turb_banda\turb_vs_ln_banda.csv")
X = Datos[['ln_B05']]  
y = Datos['turbidez']  

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.25, shuffle=True, random_state=42
)

modelo = LinearRegression()
modelo.fit(X_train, y_train)

# Predicciones
y_pred = modelo.predict(X_test)

# Métricas
r2 = r2_score(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))

print(f"R²: {r2:.4f}")
print(f"RMSE: {rmse:.4f}")

#Ver coefidiones del modelo
print("Intercepto:", modelo.intercept_)
print("Coeficientes:")
for nombre, coef in zip(X.columns, modelo.coef_):
    print(f"{nombre}: {coef:.4f}")

# Predicciones para entrenamiento y test
y_train_pred = modelo.predict(X_train)
y_test_pred = modelo.predict(X_test)

plt.figure(figsize=(10, 6))

# Entrenamiento
plt.scatter(y_train, y_train_pred, color='blue', label='Entrenamiento', alpha=0.6)

# Test
plt.scatter(y_test, y_test_pred, color='green', label='Test', alpha=0.6)

# Línea ideal (y = x)
min_val = min(min(y_train), min(y_test))
max_val = max(max(y_train), max(y_test))
plt.plot([min_val, max_val], [min_val, max_val], 'k--', lw=2, label='Ideal')

plt.xlabel('Turbidez real')
plt.ylabel('Turbidez predicha')
plt.title('Regresión Lineal: Valores Reales vs. Predichos')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()
```

## Modelo con 5 bandas

```{python}
#| code-fold: true
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
import matplotlib.pyplot as plt


Datos = pd.read_csv(r"D:\GIT\Turbidez\Datos creados\Datos_turb_banda\turb_vs_ln_banda.csv")
X = Datos[['ln_B05', 'ln_B08', 'ln_B07', 'ln_B06', 'ln_B04']]  
y = Datos['turbidez']  

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.25, shuffle=True, random_state=42
)

modelo = LinearRegression()
modelo.fit(X_train, y_train)

# Predicciones
y_pred = modelo.predict(X_test)

# Métricas
r2 = r2_score(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))

print(f"R²: {r2:.4f}")
print(f"RMSE: {rmse:.4f}")

#Ver coefidiones del modelo
print("Intercepto:", modelo.intercept_)
print("Coeficientes:")
for nombre, coef in zip(X.columns, modelo.coef_):
    print(f"{nombre}: {coef:.4f}")

# Predicciones para entrenamiento y test
y_train_pred = modelo.predict(X_train)
y_test_pred = modelo.predict(X_test)

plt.figure(figsize=(10, 6))

# Entrenamiento
plt.scatter(y_train, y_train_pred, color='blue', label='Entrenamiento', alpha=0.6)

# Test
plt.scatter(y_test, y_test_pred, color='green', label='Test', alpha=0.6)

# Línea ideal (y = x)
min_val = min(min(y_train), min(y_test))
max_val = max(max(y_train), max(y_test))
plt.plot([min_val, max_val], [min_val, max_val], 'k--', lw=2, label='Ideal')

plt.xlabel('Turbidez real')
plt.ylabel('Turbidez predicha')
plt.title('Regresión Lineal: Valores Reales vs. Predichos')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()
```
```

# Métodos de aprendizaje automático 
Proximamente...





```{python}
import numpy as np
from sklearn.datasets import load_diabetes
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
import matplotlib.pyplot as plt # Para visualización, opcional

# 1. Cargar el dataset
X, y = load_diabetes(return_X_y=True)

# 2. Seleccionar múltiples variables (características)
# En este caso, usaremos todas las características disponibles en el dataset de diabetes.
# X ya contiene todas las características por defecto cuando no se selecciona nada.
# Si quisieras seleccionar un subconjunto específico, lo harías como te mostré antes:
# selected_features_indices = [0, 2, 5, 8] # Ejemplo: indices 0, 2, 5 y 8
# X = X[:, selected_features_indices]

print(f"Dimensiones de X (características): {X.shape}") # (número_muestras, número_características)
print(f"Dimensiones de y (objetivo): {y.shape}")         # (número_muestras,)

# 3. Dividir los datos en conjuntos de entrenamiento y prueba
# Es crucial tener un conjunto de prueba para evaluar el rendimiento del modelo en datos no vistos.
# test_size=0.2 significa que el 20% de los datos se usarán para prueba.
# random_state asegura que la división sea la misma cada vez que ejecutes el código, para reproducibilidad.
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

print(f"\nDimensiones de X_train: {X_train.shape}")
print(f"Dimensiones de X_test: {X_test.shape}")
print(f"Dimensiones de y_train: {y_train.shape}")
print(f"Dimensiones de y_test: {y_test.shape}")

# 4. Crear y entrenar el modelo de Regresión Lineal Múltiple
# La clase LinearRegression de scikit-learn es la que necesitas.
model = LinearRegression()

# Entrenar el modelo con los datos de entrenamiento
model.fit(X_train, y_train)

# 5. Hacer predicciones en el conjunto de prueba
y_pred = model.predict(X_test)

# 6. Evaluar el rendimiento del modelo
# Métricas comunes para regresión:

# Error Cuadrático Medio (Mean Squared Error - MSE)
# Mide el promedio de los cuadrados de los errores.
mse = mean_squared_error(y_test, y_pred)
print(f"\nError Cuadrático Medio (MSE): {mse:.2f}")

# Coeficiente de Determinación (R-squared o R2)
# Indica la proporción de la varianza en la variable dependiente que es predecible a partir de las variables independientes.
# Un valor de 1.0 indica que el modelo predice perfectamente la variable objetivo.
r2 = r2_score(y_test, y_pred)
print(f"Coeficiente de Determinación (R2): {r2:.2f}")

# Opcional: Analizar los coeficientes del modelo y el intercepto
print(f"\nCoeficientes del modelo (pendientes para cada característica):")
# Los nombres de las características para el dataset de diabetes son:
feature_names = load_diabetes().feature_names
for i, coef in enumerate(model.coef_):
    print(f"  {feature_names[i]}: {coef:.2f}")

print(f"Intercepto del modelo: {model.intercept_:.2f}")

# Opcional: Visualizar las predicciones vs. los valores reales
# Esto es más fácil de visualizar con una sola característica,
# pero con múltiples características puedes graficar predicciones vs. valores reales.
plt.figure(figsize=(10, 6))
plt.scatter(y_test, y_pred, alpha=0.6)
plt.plot([y.min(), y.max()], [y.min(), y.max()], 'r--', lw=2) # Línea de identidad (predicciones perfectas)
plt.xlabel("Valores Reales (y_test)")
plt.ylabel("Predicciones del Modelo (y_pred)")
plt.title("Valores Reales vs. Predicciones del Modelo de Regresión Lineal Múltiple")
plt.grid(True)
plt.show()
```